@app.route('/individual_businesses/upload', methods=['POST'])
def upload_individual_business_excel():
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': '로그인이 필요합니다.'})
        
    if 'file' not in request.files:
        return jsonify({'success': False, 'message': '파일이 없습니다.'})
        
    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'message': '선택된 파일이 없습니다.'})
        
    if file and (file.filename.endswith('.xlsx') or file.filename.endswith('.xls')):
        try:
            # 엑셀 파일 읽기
            import pandas as pd
            df = pd.read_excel(file)
            
            # 컬럼명 정리 (공백 제거)
            df.columns = [str(col).strip() for col in df.columns]
            print(f"엑셀 컬럼명: {list(df.columns)}")  # 디버깅용 로그
            
            # 컬럼명 정규화 함수 (공백, 특수문자 제거)
            def normalize_col(col):
                return col.replace(' ', '').replace('\n', '').replace('\r', '').replace('\t', '')
            
            # 정규화된 컬럼명 매핑 생성
            normalized_cols = {normalize_col(col): col for col in df.columns}
            print(f"정규화된 컬럼명: {normalized_cols}")  # 디버깅용 로그
            
            # 컬럼 매핑 (엑셀 헤더 -> DB 컬럼) - 정규화된 이름으로 매핑
            column_map_normalized = {
                '기업명': 'company_name',
                '대표자명': 'representative_name',
                '출생년도': 'birth_year',
                '설립년도': 'establishment_year',
                '가족주주여부': 'is_family_shareholder',
                '타인주주여부': 'is_other_shareholder',
                '업종': 'industry_type',
                '재무제표연도': 'financial_year',
                '기준연도': 'financial_year',
                '종업원수': 'employee_count',
                '종업원수(명)': 'employee_count',
                '총자산': 'total_assets',
                '총자산(억)': 'total_assets',
                '자본총계': 'total_capital',
                '자본총계(억)': 'total_capital',
                '매출액': 'revenue',
                '매출액(억)': 'revenue',
                '당기순이익': 'net_income',
                '당기순이익(억)': 'net_income',
                '사업장주소': 'address',
                '사업자주소': 'address',
                '주소': 'address',
                '사업자번호': 'business_number',
                '전화번호': 'phone_number',
            }
            
            # 실제 엑셀 컬럼명을 기반으로 매핑 생성
            column_map = {}
            for norm_key, db_col in column_map_normalized.items():
                # 정규화된 키로 매칭
                if norm_key in normalized_cols:
                    column_map[normalized_cols[norm_key]] = db_col
                # 원본 컬럼에도 직접 확인
                for excel_col in df.columns:
                    if norm_key in normalize_col(excel_col):
                        column_map[excel_col] = db_col
            
            print(f"최종 매핑: {column_map}")  # 디버깅용 로그
            
            # 엑셀 헤더에 (억) 포함 여부 확인 (이미 억 단위인지)
            already_in_billion = any('(억)' in str(col) or '억' in str(col) for col in df.columns)
            
            conn = get_db_connection()
            cursor = conn.cursor()
            
            # 테이블 존재 확인 및 생성
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS individual_business_owners (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    company_name TEXT,
                    representative_name TEXT,
                    birth_year TEXT,
                    establishment_year TEXT,
                    is_family_shareholder TEXT,
                    is_other_shareholder TEXT,
                    industry_type TEXT,
                    financial_year TEXT,
                    employee_count TEXT,
                    total_assets TEXT,
                    total_capital TEXT,
                    revenue TEXT,
                    net_income TEXT,
                    address TEXT,
                    business_number TEXT,
                    phone_number TEXT,
                    fax_number TEXT,
                    memo TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.commit()
            
            success_count = 0
            fail_count = 0
            first_error = None
            skip_count = 0
            
            for _, row in df.iterrows():
                try:
                    # 데이터 정리
                    data = {}
                    for kor_col, db_col in column_map.items():
                        if kor_col in row:
                            val = row[kor_col]
                            if pd.isna(val):
                                val = None
                            else:
                                # 년도 필드 처리 (.0 제거)
                                if db_col in ['birth_year', 'establishment_year', 'financial_year']:
                                    try:
                                        val = str(int(float(val)))
                                    except (ValueError, TypeError):
                                        val = str(val) if val else None
                                # 재무 데이터 처리
                                elif db_col in ['total_assets', 'total_capital', 'revenue', 'net_income']:
                                    try:
                                        num_val = float(val)
                                        # 이미 억 단위면 그대로, 아니면 변환
                                        if not already_in_billion:
                                            val = round(num_val / 100000000, 1)
                                        else:
                                            val = num_val  # 이미 억 단위
                                    except (ValueError, TypeError):
                                        val = None
                                # 종업원수 처리 (.0 제거)
                                elif db_col == 'employee_count':
                                    try:
                                        val = str(int(float(val)))
                                    except (ValueError, TypeError):
                                        val = str(val) if val else None
                            data[db_col] = val
                    
                    if not data.get('company_name'):
                        skip_count += 1
                        continue
                        
                    # 중복 확인 및 업데이트/삽입
                    cursor.execute("SELECT id FROM individual_business_owners WHERE business_number = ?", (data.get('business_number'),))
                    existing = cursor.fetchone()
                    
                    if existing:
                        # 업데이트
                        set_clause = ', '.join([f"{k} = ?" for k in data.keys()])
                        values = list(data.values())
                        values.append(data.get('business_number'))
                        
                        cursor.execute(f'''
                            UPDATE individual_business_owners 
                            SET {set_clause}
                            WHERE business_number = ?
                        ''', values)
                    else:
                        # 삽입
                        data['created_at'] = '0001-01-01 00:00:00' # 초기 등록일은 맨 뒤로 가도록 설정
                        columns = ', '.join(data.keys())
                        placeholders = ', '.join(['?' for _ in data])
                        cursor.execute(f'''
                            INSERT INTO individual_business_owners ({columns})
                            VALUES ({placeholders})
                        ''', list(data.values()))
                        
                    success_count += 1
                except Exception as e:
                    print(f"Row processing error: {e}")
                    if first_error is None:
                        first_error = str(e)
                    fail_count += 1
                    
            conn.commit()
            conn.close()
            
            return jsonify({
                'success': True if success_count > 0 else False, 
                'message': f'총 {success_count}건 처리 완료 (실패 {fail_count}건, 스킵 {skip_count}건)' + (f' | 첫번째 오류: {first_error}' if first_error else '')
            })
            
        except Exception as e:
            return jsonify({'success': False, 'message': f'엑셀 처리 중 오류: {str(e)}'})
            
    return jsonify({'success': False, 'message': '엑셀 파일만 업로드 가능합니다.'})

# --- 개인사업자 상세 조회 및 메모/히스토리 API ---

@app.route('/individual_businesses/<int:id>/detail')
def get_individual_business_detail(id):
    """개인사업자 상세 정보, 메모, 히스토리 조회"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': '로그인이 필요합니다.'})
    
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        # 컬럼 존재 확인 및 추가
        cursor.execute("PRAGMA table_info(individual_business_owners)")
        columns = [col[1] for col in cursor.fetchall()]
        if 'assigned_user_id' not in columns:
            cursor.execute("ALTER TABLE individual_business_owners ADD COLUMN assigned_user_id TEXT")
        if 'status' not in columns:
            cursor.execute("ALTER TABLE individual_business_owners ADD COLUMN status TEXT DEFAULT '접촉대기'")
        if 'memo' not in columns:
            cursor.execute("ALTER TABLE individual_business_owners ADD COLUMN memo TEXT")
        
        # 히스토리 테이블 생성
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS individual_business_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                business_id INTEGER NOT NULL,
                type TEXT,
                content TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT,
                FOREIGN KEY (business_id) REFERENCES individual_business_owners(id)
            )
        ''')
        
        # 히스토리 테이블 컬럼 확인 및 추가 (created_by 등)
        cursor.execute("PRAGMA table_info(individual_business_history)")
        h_cols = [c[1] for c in cursor.fetchall()]
        if 'created_by' not in h_cols:
             cursor.execute("ALTER TABLE individual_business_history ADD COLUMN created_by TEXT")
             
        conn.commit()
        
        # 데이터 조회
        cursor.execute("SELECT * FROM individual_business_owners WHERE id = ?", (id,))
        row = cursor.fetchone()
        
        if not row:
            return jsonify({'success': False, 'message': '기업 정보를 찾을 수 없습니다.'})

        memo = row['memo'] if row else ''
        status = row['status'] if 'status' in row.keys() and row['status'] else None
        assigned_user_id = row['assigned_user_id'] if 'assigned_user_id' in row.keys() else None
        
        # 히스토리 조회
        cursor.execute('''
            SELECT type, content, created_at, created_by FROM individual_business_history
            WHERE business_id = ? ORDER BY created_at DESC
        ''', (id,))
        history = [{'type': h['type'], 'content': h['content'], 'created_at': h['created_at'], 'created_by': h['created_by']} for h in cursor.fetchall()]
        
        return jsonify({
            'success': True,
            'data': {
                'memo': memo,
                'status': status,
                'assigned_user_id': assigned_user_id,
                'history': history
            }
        })
    except Exception as e:
        print(f"상세 조회 오류: {e}")
        return jsonify({'success': False, 'message': str(e)})
    finally:
        conn.close()

@app.route('/individual_businesses/<int:id>/memo', methods=['POST'])
def save_individual_business_memo(id):
    """개인사업자 메모 및 상태 저장"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': '로그인이 필요합니다.'})
    
    current_user_id = session.get('user_id')
    
    try:
        data = request.get_json()
        memo = data.get('memo', '')
        new_status = data.get('status') # 상태 변경 요청이 있을 경우
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 현재 상태 및 담당자 조회
        cursor.execute("SELECT status, assigned_user_id FROM individual_business_owners WHERE id = ?", (id,))
        row = cursor.fetchone()
        
        if not row:
            conn.close()
            return jsonify({'success': False, 'message': '기업 정보를 찾을 수 없습니다.'})

        current_status = row['status']
        assigned_user_id = row['assigned_user_id']
        
        updates = ["memo = ?"]
        params = [memo]
        
        # 상태 업데이트 로직
        if new_status and new_status != current_status:
            updates.append("status = ?")
            params.append(new_status)
            
            # 상태 변경 시 등록일(최근활동일) 갱신
            updates.append("created_at = CURRENT_TIMESTAMP")
            
            # 접촉중으로 변경 시, 담당자가 없으면 현재 사용자로 지정
            if new_status == '접촉중':
                if not assigned_user_id:
                    updates.append("assigned_user_id = ?")
                    params.append(current_user_id)
            
            # 접촉해제로 변경 시, 담당자를 유지할지 해제할지? 
            # -> 보통 해제하면 다른 사람이 가져갈 수 있어야 하므로 assigned_user_id를 NULL로 하거나, 
            #    그냥 '접촉해제' 상태로 두면 리스트 필터링에서 보이게 되므로(status='접촉해제') OK.
            #    여기서는 담당자 정보는 이력상 남겨두고 상태만 변경함. (다른 사람이 '접촉중'으로 변경 시 덮어써짐)
            
        params.append(id)
        
        cursor.execute(f"UPDATE individual_business_owners SET {', '.join(updates)} WHERE id = ?", params)
        conn.commit()
        conn.close()
        
        return jsonify({'success': True, 'message': '저장되었습니다.'})
    except Exception as e:
        print(f"메모 저장 오류: {e}")
        return jsonify({'success': False, 'message': str(e)})

@app.route('/individual_businesses/<int:id>/history', methods=['POST'])
def add_individual_business_history(id):
    """개인사업자 히스토리 추가 및 상태 변경"""
    if 'user_id' not in session:
        return jsonify({'success': False, 'message': '로그인이 필요합니다.'})
    
    current_user_id = session.get('user_id')
    current_user_name = session.get('user_name', current_user_id)
    
    try:
        data = request.get_json()
        history_type = data.get('type', '기타')
        content = data.get('content', '')
        new_status = data.get('status')
        
        if not content:
            return jsonify({'success': False, 'message': '내용을 입력해주세요.'})
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 히스토리 추가
        # created_by 컬럼이 있는지 확인 (history 테이블)
        cursor.execute("PRAGMA table_info(individual_business_history)")
        cols = [c[1] for c in cursor.fetchall()]
        if 'created_by' not in cols:
             cursor.execute("ALTER TABLE individual_business_history ADD COLUMN created_by TEXT")
        
        cursor.execute('''
            INSERT INTO individual_business_history (business_id, type, content, created_by)
            VALUES (?, ?, ?, ?)
        ''', (id, history_type, content, current_user_name))
        
        # 상태 업데이트 로직
        if new_status:
            cursor.execute("SELECT status, assigned_user_id FROM individual_business_owners WHERE id = ?", (id,))
            row = cursor.fetchone()
            if row:
                current_status = row['status']
                assigned_user_id = row['assigned_user_id']
                
                if new_status != current_status:
                    updates = ["status = ?"]
                    params = [new_status]
                    
                    # 상태 변경 시 등록일(최근활동일) 갱신
                    updates.append("created_at = CURRENT_TIMESTAMP")
                    
                    if new_status == '접촉중':
                        if not assigned_user_id:
                             updates.append("assigned_user_id = ?")
                             params.append(current_user_id)
                    elif new_status == '접촉중' and assigned_user_id and assigned_user_id != current_user_id:
                        # 이미 다른 담당자가 있는데 접촉중으로 바꾼다면? -> 강제 탈취 (마지막 접촉자 기준)
                        updates.append("assigned_user_id = ?")
                        params.append(current_user_id)
                        
                    params.append(id)
                    cursor.execute(f"UPDATE individual_business_owners SET {', '.join(updates)} WHERE id = ?", params)
        
        conn.commit()
        conn.close()
        
        return jsonify({'success': True, 'message': '히스토리가 추가되었습니다.'})
    except Exception as e:
        print(f"히스토리 추가 오류: {e}")
        return jsonify({'success': False, 'message': str(e)})

# ==========================================
# LYS Feature Functions (Seminars & Blog)
# ==========================================
def init_lys_tables():
    conn = get_db_connection()
    try:
        # 세미나 테이블
        conn.execute('''
            CREATE TABLE IF NOT EXISTS Seminars (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                description TEXT,
                date TEXT,
                time TEXT,
                location TEXT,
                image_url TEXT,
                link_url TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # 블로그/뉴스 테이블
        conn.execute('''
            CREATE TABLE IF NOT EXISTS BlogPosts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                category TEXT,
                summary TEXT,
                thumbnail_url TEXT,
                link_url TEXT,
                publish_date TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # 세미나 신청자 테이블 (별도 관리)
        conn.execute('''
            CREATE TABLE IF NOT EXISTS SeminarRegistrations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                seminar_title TEXT NOT NULL,
                name TEXT NOT NULL,
                phone TEXT NOT NULL,
                company_name TEXT,
                position TEXT,
                biz_no TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        conn.commit()
    except Exception as e:
        print(f"Error initializing LYS tables: {e}")
    finally:
        conn.close()

@app.route('/lys')
def lys_page_v2():
    conn = get_db_connection()
    seminars = []
    blog_posts = []
    counts = {
        "inquiry": 15,
        "seminar": 11
    }
    try:
        # 세미나 목록
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM Seminars ORDER BY date ASC LIMIT 3")
        for row in cursor.fetchall():
            seminars.append({
                "id": row[0], "title": row[1], "description": row[2],
                "date": row[3], "time": row[4], "location": row[5],
                "image_url": row[6], "link_url": row[7]
            })

        # 블로그 목록
        cursor.execute("SELECT * FROM BlogPosts ORDER BY publish_date DESC LIMIT 4")
        for row in cursor.fetchall():
            blog_posts.append({
                "id": row[0], "title": row[1], "category": row[2],
                "summary": row[3], 
                "thumbnail_url": row[4],
                "link_url": row[5], "publish_date": row[6]
            })
            
        # 카운트 계산
        cursor.execute("SELECT COUNT(*) FROM SeminarRegistrations")
        sem_count_db = cursor.fetchone()[0]
        counts["seminar"] += sem_count_db

        # For General Inquiries
        try:
            cursor.execute("SELECT COUNT(*) FROM Contact_History")
            inq_count_db = cursor.fetchone()[0]
            counts["inquiry"] += inq_count_db
        except:
            pass

    except Exception as e:
        print(f"Error loading LYS data: {e}")
    finally:
        conn.close()

    return render_template('lys_main.html', news_items=blog_posts, seminars=seminars, counts=counts)


@app.route('/lys/admin/seminars', methods=['GET', 'POST', 'DELETE'])
def manage_seminars():
    if not session.get('logged_in'):
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    conn = get_db_connection()
    try:
        if request.method == 'POST':
            data = request.json
            conn.execute('INSERT INTO Seminars (title, description, date, time, location, link_url) VALUES (?,?,?,?,?,?)',
                         (data.get('title'), data.get('description'), data.get('date'), data.get('time'), data.get('location'), data.get('link_url')))
            conn.commit()
            return jsonify({"success": True})
        elif request.method == 'DELETE':
            conn.execute('DELETE FROM Seminars WHERE id = ?', (request.args.get('id'),))
            conn.commit()
            return jsonify({"success": True})
        else:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM Seminars ORDER BY date DESC')
            rows = cursor.fetchall()
            seminars = []
            for row in rows:
                seminars.append({"id": row[0], "title": row[1], "description": row[2], "date": row[3], "time": row[4], "location": row[5], "link_url": row[7]})
            return jsonify({"success": True, "data": seminars})
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500
    finally:
        conn.close()

@app.route('/lys/admin/blog', methods=['GET', 'POST', 'DELETE'])
def manage_blog():
    if not session.get('logged_in'):
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    conn = get_db_connection()
    try:
        if request.method == 'POST':
            data = request.json
            conn.execute('INSERT INTO BlogPosts (title, category, summary, thumbnail_url, link_url, publish_date) VALUES (?,?,?,?,?,?)',
                         (data.get('title'), data.get('category'), data.get('summary'), data.get('thumbnail_url'), data.get('link_url'), data.get('publish_date')))
            conn.commit()
            return jsonify({"success": True})
        elif request.method == 'DELETE':
            conn.execute('DELETE FROM BlogPosts WHERE id = ?', (request.args.get('id'),))
            conn.commit()
            return jsonify({"success": True})
        else:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM BlogPosts ORDER BY publish_date DESC')
            rows = cursor.fetchall()
            posts = []
            for row in rows:
                posts.append({"id": row[0], "title": row[1], "category": row[2], "summary": row[3], "thumbnail_url": row[4], "link_url": row[5], "publish_date": row[6]})
            return jsonify({"success": True, "data": posts})
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500
    finally:
        conn.close()

# 아티팩트 이미지 서빙 (중요)
if __name__ == '__main__':
    # 앱 시작 시 테이블 초기화
    print("\n=== 데이터베이스 테이블 초기화 ===")
    try:
        init_user_tables()
        print("? 사용자 테이블 초기화 완료")
    except Exception as e:
        print(f"? 사용자 테이블 초기화 실패: {e}")
    
    try:
        init_business_tables()
        print("? 비즈니스 테이블 초기화 완료")
    except Exception as e:
        print(f"? 비즈니스 테이블 초기화 실패: {e}")
    
    try:
        init_pipeline_tables()
        print("? 영업 파이프라인 테이블 초기화 완료")
    except Exception as e:
        print(f"? 영업 파이프라인 테이블 초기화 실패: {e}")
    
    try:
        init_ys_honers_tables()
        print("? YS Honers 테이블 초기화 완료")
    except Exception as e:
        print(f"? YS Honers 테이블 초기화 실패: {e}")
    
    try:
        init_individual_business_tables()
        print("? 개인사업자 테이블 초기화 완료")
    except Exception as e:
        print(f"? 개인사업자 테이블 초기화 실패: {e}")

    try:
        init_lys_tables()
        print("? LYS 테이블 초기화 완료")
    except Exception as e:
        print(f"? LYS 테이블 초기화 실패: {e}")
    
    # 서버 시작
    port = int(os.environ.get('PORT', 5000))
    print(f"\n=== Flask 서버 시작 ===")
    print(f"Host: 0.0.0.0")
    print(f"Port: {port}")
    print(f"Debug: {not os.environ.get('RENDER')}")  # Render에서는 debug=False
    
    app.run(
        host='0.0.0.0', 
        port=port, 
        debug=not os.environ.get('RENDER')  # Render에서는 debug=False
    )
